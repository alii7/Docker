docker run hello-world          # to create container(an instance of an image)
sudo docker run -it centos /bin/bash      # -it(interactive mode), /bin/bash( run the bash shell once CentOS is up and running)
docker images                # to see the list of Docker images on the system
docker rmi ImageID           # to remove Docker images on the system
sudo docker images -q        # to return only the Image ID’s of the images
docker inspect image_name    # to see the details of an image or container  (image_name = Repository)
docker ps                    # to list all of the containers on the machine (currently running)
docker ps -a                 # to list all of the containers on the system
docker history ImageID       # to see all the commands that were run with an image via a container
docker history image_name    # to see all the commands that were run with an image via a container
docker top ContainerID       # to see the top processes within a container
docker stop ContainerID      # to stop a running container
docker rm ContainerID        # to delete a container
docker stats ContainerID     # to provide the statistics of a running container (CPU and memory utilization of the Container)
docker attach ContainerID    # to attach to a running container

Once you have attached to the Docker container, you can run the above command to see the process utilization in that Docker container

docker pause ContainerID     # to pause the processes in a running container
docker unpause ContainerID   # to unpause the processes in a running container
docker kill ContainerID      # to kill the processes in a running container


service docker stop           # to stop the Docker daemon process
service docker start          # to start the Docker daemon process


Ctrl+P+Q     # to exit out of the container. It ensures that the container still exists even after we exit from the container.
If we had to exit out of the container directly, then the container itself would be destroyed.

There is an easier way to attach to containers and exit them cleanly without the need of destroying them: NSENTER
1) docker run --rm -v /usr/local/bin:/target jpetazzo/nsenter     # install nsenter image
2) docker inspect image_ID | grep Pid                             # to get the Process ID via the Docker inspect command and filtering it via the Pid


nsenter –m –u –n –p –i –t containerID command         #  NSENTER SYNTAX
sudo nsenter –m –u –n –p –i –t 2978 /bin/bash         #  NSENTER EXAMPLE

-u is used to mention the Uts namespace
-m is used to mention the mount namespace
-n is used to mention the network namespace
-p is used to mention the process namespace
-i s to make the container run in interactive mode.
-t is used to connect the I/O streams of the container to the host OS.
containerID − This is the ID of the container.
command − This is the command to run within the container.

CONSEQUENCE OF NSENTER:
The prompt changes to the bash shell directly when we issue the nsenter command.
We then issue the exit command. But you would notice that when we run the nsenter command, the container is still up and running.(NOT DESTROYED)

FROM ubuntu                                 #
MAINTAINER demousr@gmail.com                #
                                            #
RUN apt-get update                          #   DOCKERFILE EXAMPLE (Dockerfile)
RUN apt-get install –y nginx                #
CMD [“echo”,”Image created”]                #

FROM            : which base image you want to base your image (we are creating an image from the ubuntu image)
MAINTAINER      : the person who is going to maintain this image  (just mention the email ID)
RUN             : to run instructions against the image
CMD             : to display a message to the user


docker build  -t ImageName:TagName dir              # to build your own Docker images
dir : The directory where the Docker File is present

docker tag imageID Repositoryname                     # to tag an image to the relevant repository
docker tag ab0c1d3744dd demousr/demorep:1.0           # TAG EXAMPLE
docker push Repositoryname                            # to push images to the Docker Hub
docker push demousr/demorep:1.0                       # PUSH EXAMPLE



In Docker, the containers themselves can have applications running on ports. 
When you run a container, if you want to access the application in the container via a port number, you need to map the port number of the container to the port number of the Docker host.

To understand what ports are exposed by the container, you should use the Docker inspect command to inspect the image.

docker inspect Container/Image          # to return low-level information on the container or image  (in JSON format)
docker run -p 8080:8080 -p 50000:50000 jenkins     # to run Jenkins and map the ports

8080 ==>  the Docker host port
50000 ==>  the Docker container port

When you open the browser and navigate to the Docker host on port 8080, you will see Jenkins up and running.

-----------------------------------------------------------------------------------------------------------------------------------------

EXPOSE 80 :  to expose port 80 of Apache in the container to the Docker host
CMD [“apache2ctl”, “-D”, “FOREGROUND”]   :   to run apache2 in the background

CMD command param1          # to execute a command at runtime when the container is executed
CMD [“echo” , “hello world”]      #  CMD EXAMPLE

ENTRYPOINT command param1     # to execute commands at runtime for the container. But, this command is more flexible.

ENV key value                 # to set environment variables in the container
ENV var1=Tutorial var2=point  # ENVIRONMENT EXAMPLE

WORKDIR dirname               # to set the working directory of the container
WORKDIR /newtemp              # WORKDIR EXAMPLE

Docker takes care of the networking aspects so that the containers can communicate with other containers and also with the Docker Host.
ifconfig                  # to see the Docker Ethernet adapter
docker network ls         # to list all the networks associated with Docker on the host
docker network inspect network_name     # to output all the details about the network
docker network inspect bridge           # EXAMPLE

One can create a network in Docker before launching containers.

docker network create –-driver drivername name      # to create network
docker network create –-driver bridge new_nw        # EXAMPLE
docker run –it –network=new_nw ubuntu:latest /bin/bash     # to attach the new network when launching the container



